## How to run:
	Install the libraries
	Run the Main.py file

## Libraries to install and import:
	PIL (pillow) - for images
	Networkx - for graph nodes
	Matplotlib - for graph axis
	CustomTkinter and Tkinter - for User Interface

## Objectives:
	1.	Menu
		1.	A small icon that changes the visual mode (light or dark) for the menu and this can be represented with a 	screen for prolonged periods and that the light mode allows the user to retain their attention on the application. When going between pages, the same appearance mode must be kept.
		2.	A search bar that recommends categories or DSAs as the user types in characters (not case sensitive) – this can use a priority queue to provide more efficient and relevant results, starting from whether it is in the name or characteristic, then how close the letters that match is to the beginning of the word. The app will recommend the DSAs in a drop-down menu under the search bar – depending on whether what the user typed is in the DSA’s name or characteristics – which only happens when the user enters at least 2 letters.
		3.	A logo on every page that allows the user to go back to main menu on click. When hovering on the logo, it shows the user that it can click on it. This logo will be the title in the header.
		4.	Using a scrollable frame, display all the available DSAs and their characteristics. The DSA name will be a button with a larger font that will take the user from the main menu straight to the revision page of that specific DSA.
		5.	The user can sort or filter the results with a tick box on the side that the user can click, which will be based on the characteristics the DSAs can have in relation to A-level specification or what type of DSA they are.
	2.	Learning resources
		1.	Inherit the page class from the base page and initiate an instance when the user wants to look at the resources page for a certain DSA. From the main page, the user will be given three options when they click on a certain DSA, which the user can choose from doing the quiz, looking at the revision page or use the visualiser. When the revision page is clicked, the page should clear, and the revision page should be initialised.
		2.	The page itself will be concise notes in the form of a table and a diagram of the DSA and have the normal footer and header. The user will be given the option to take a quiz or look at the visualizer at the top of the page in the header.
	3.	Quizzes
		1.	The quiz will output questions in order of difficulty (easy, medium, hard). The questions will be timed depending on its difficulty and will implement a priority queue – using the questions difficulty, increasing the difficulty as the questions go on.
		2.	Keep track of the score of the user in both unlimited and quiz mode, where it would be out of 7 in quiz mode. The timer for each question will be shown, and when the user submits an answer, there will be a suitable message – whether the user got it right or wrong, or the user did not select an answer. If the user’s score will increment, only if they get the answer right.
		3.	The questions are premade and stored into a pool of questions, with each question being an object. Create a class for the questions that will include, the question text itself, the 4 multiple choices, the correct answer, the topics the question is related to, and the question difficulty.
		4.	Add another mode in the questions, so the user can do an unlimited number of questions until they do not get any wrong, where all the questions related to the topic will be in it, and the questions they get wrong will be asked again – the questions will not be sorted in order of difficulty, so the use of a normal queue would be fine.
		5.	When the user wants to do a quiz, there will be a ‘start’ button that will be disabled until the user selects the topics they want and whether they want to do simple or unlimited mode.
		6.	When the user completes the quiz, there will be an appropriate message that will tell the user the quiz has been completed and a comment based on their performance. There will be a button that allows the user to go back to the basic quiz page for them to redo the quiz if they want to.
	4.	Sorting and Searching
		1.	The user can change the speed of the animation using a slider that changes the time it takes for each step of the animation. The user can pause and play the animation. 
		2.	For the sorting, the visualiser can show bubble, merge and insertion and there will be two panels so the user can see and compare the speed of two different sorts – this can be done using a separate button that starts both sorts at the same time with the same data set. The user can choose what sort to visualise in each panel by using a drop-down menu and selecting another sort. There will be visualiser 1 and 2, where the titles and buttons will be tailored to the sort.
		3.	The sort will randomly generate a suitable number of values that will be represented as a bar chart. Each bar will have its value on the top of it and the index number it is at beneath it.
		4.	When the unsorted, the bars are red, as they are being compared, they turn a different colour, and when they are finally sorted, they become green.
		5.	For the searches, there will be two types of searches: linear and binary. They will also be represented as bar charts in the same way as it is in the sorting visualiser. And there will be two panels that cannot be changed.
		6.	The searches can also be compared, but there will be an entry for the value to be searched that the user must input and a generate data set. When comparing both, both visualisers must have data – there will be another button that can generate a shared data set on both visualisers. The user can only start the search if there is a data set and a value in the search entry.
	5.	Arrays
		1.	There will be two types of arrays – static and dynamic. For the static arrays, the user can either look at a normal array, queue or stack. There will only be one dynamic array: linked list. The number of nodes in each array will have a maximum of 10.
		2.	For the static array, keep track of how much of the array is filled using the in-built ‘len’ function. The array will have a set length and if an overflow error occurs, the length doubles until a maximum is reached. Each node will be presented as a box and the data within it, with its index underneath it. The user can insert or delete their own custom data to the visualiser or even search for an item.
		3.	For the queues, there will be the use of front and rearpointers instead of using the ‘len’ function. This will be a subclass of the array and will be 3 different types: normal queue, circular queue and a priority queue (that uses a circular queue as it is better to represent and more memory efficient). Once the front pointer reaches the end of the normal queue, the queue cannot be used again but for the priority queue, the pointers can loop back around if it has reached the end. The front pointer will point to the first item in the queue and the rear pointer would point to the last item. The operations will change from insert and delete to enqueue and dequeue – where dequeue will just be a button with no entry.
		4.	For the stack, the nodes will be presented vertically instead of horizontally and there will be one top pointer that points at the top item in the stack.
		5.	The linked list will show how each node contains an additional piece of information which is the next index it points to (this can be either a placeholder index i.e. 1,2,3 or their actual memory locations). These will be represented as an arrow that points to the next node instead of having all the nodes next to each other. The user can insert or delete their own custom data to the visualiser at the head or tail of the linked list or search for a value.
	6.	Graphs and Trees
		1.	Each datum will be presented as circles which will be the nodes with the suitable information inside. These will be scattered in the allocated space for the visualizer and the connections between each node will be shown using arrows. There will only be a maximum of 10 nodes – each valued at 1-9 for simplicity.
		2.	The user can input or delete their own, custom data – using the operations that are appropriate for the DSA. The arrows can be weighted or unweighted which the user can toggle.
		3.	The user can change the speed of the animation. The user can pause and play the animation. The data being compared in the animation will be highlighted in a different colour.
		4.	The user can choose to run a depth-first search or breadth-first search on the graph, but the user must choose which node to start from – creating a list which shows the order each node was visited. During the traversal, the nodes will be highlighted in corresponding order in the animationThere will be two entries: start node and the search node, where the start node is necessary, but the search node is not. If the search node is left blank, then the whole graph is traversed anyway. When the search node is reached, the node will be highlighted a different colour, and the search will stop.
		5.	The nodes of the graph can be draggable so the user can see how the nodes are connected better, since the arrows can overlap, and the information can be obscured.
		6.	The tree will be a subclass of the graph, where the structure of the nodes will be hierarchal, and you connect nodes up the tree. These nodes will not be draggable since it would be better to visualise as a hierarchy.
		7.	The basic tree traversals (pre, post) can be visualized to create a list to search for a value. There will be an output list which shows the order each node was visited. The DFS and BFS functions will also be applicable for the tree. The structure of the nodes will be calculated using the maximum depth of deepest leaf and scaling the y-axis and coordinates off this, and the x-axis will be scaled using the weights of each node and their subtrees as ratios compared to other nodes on the same layer.
		8.	The binary tree will inherit from the basic tree – with the restrictions that the maximum number of children a node can have will be 2. The in-order tree traversal can be performed since it is only well-defined in binary trees. Other traversals and searches will work as well.
	7.	Animations
		1.	In each DSA, there will be animations to show the basic operations of the DSA. Each step of the animation will be shown through a playback slider that activates when an operation starts and increments each step. The user can pause and play the animation once it has started – this button of pausing and playing will use characters like pausing a video online or in games. When the playback slider is ever at the last value (at the end), then the pause/play button would instead restart the animation (replacing the symbol with a suitable replay one). 
		2.	The user can drag the playback slider to go to specific steps of the operation or control it using buttons that can skip to the end, restart or decrement/increment exactly one step of the animation.
		3.	The user can control the animation speed when it is running by using another slider – the larger the value of the slider, the faster the animation.
